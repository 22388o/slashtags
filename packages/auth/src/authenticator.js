import {
  DEFAULT_CURVE,
  DEFAULT_CHALLENGE_LENGTH,
  PROLOGUE
} from './constants.js'
import {
  generateChallenge,
  createHandshake,
  validateKeyForCurve
} from './crypto.js'
import { addSession, hex } from './sessions.js'
import * as msgs from './messages.js'
import bint from 'bint8array'

// TODO: use the PROLOGUE for MITM attack prevention, and return mixedHash

/**
 * @param {KeyPair} keypair - Authenticator's static keypair
 * @param {object} [config] - Authenticator's optional configurations
 * @param {Curve} [config.curve] - Eliptical curve used to create the hanshake
 * @param {JSON} [config.metadata] - Metadata object
 * @param {number} [config.challengeLength]
 * @returns {{
 *  config: {curve: Curve, challengeLength: number, metdata?: JSON},
 *  initiator: Initiator,
 *  responder: Responder
 * }}
 */
export const createAuth = (keypair, config = {}) => {
  // Defaults
  const curve = config.curve || DEFAULT_CURVE
  const challengeLength = config.challengeLength || DEFAULT_CHALLENGE_LENGTH
  const _config = { challengeLength, curve, metadata: config.metadata }

  /** Validate that the keypair is generated by the same curve used in handshake */
  validateKeyForCurve(curve, keypair.publicKey, keypair.secretKey)

  // Initiator

  /**
   * Verify a responder's attestation
   * @param {Handshake} handshake
   * @param {Uint8Array} remotePK
   * @param {Uint8Array} attestation
   * @throws {Error} If the attestation is invalid
   * @returns  {{
   *  metadata: JSON,
   *  responderPK: Uint8Array,
   * }}
   */
  const _verifyResponder = (handshake, remotePK, attestation) => {
    const payload = handshake.recv(attestation)

    const { metadata: ResponderMetadata, rest: responderPK } =
      msgs.decodePayload(payload)

    const metadata = JSON.parse(new TextDecoder().decode(ResponderMetadata))

    return {
      metadata,
      responderPK
    }
  }

  /**
   * Respond to the Responder's challenge.
   * Optionally: override metadata for this attestation
   * @param {Uint8Array} remotePK
   * @param {Uint8Array} challenge
   * @param {JSON} [metdata] - Custom metadata (overrides responder metadata)
   */
  const respond = (remotePK, challenge, metdata) => {
    validateKeyForCurve(curve, remotePK)

    const metadata = new TextEncoder().encode(
      JSON.stringify(metdata || config.metadata)
    )

    const handshake = createHandshake(true, keypair, { curve })
    handshake.initialise(PROLOGUE, remotePK)

    const payload = msgs.encodePayload(metadata, challenge)
    const attestation = handshake.send(payload)

    return {
      attestation,
      verifyResponder: (/** @type {Uint8Array} */ responderAttestation) =>
        _verifyResponder(handshake, remotePK, responderAttestation)
    }
  }

  // Responder

  /**
   * Active sessions tracked by the responder
   * @type {Map<string, Session>}
   */
  const sessions = new Map()

  /**
   * Create a new session and return an encoded tuple (challenge, responderPK)
   * @param {number} timeout - Timeout for the session in miliseconds
   * @param {JSON} [metdata] - Custom metadata (overrides responder metadata)
   * @returns {Uint8Array} challenge
   */
  const newChallenge = (timeout, metdata) => {
    const challenge = generateChallenge(challengeLength)

    const metadata = new TextEncoder().encode(
      JSON.stringify(metdata || config.metadata)
    )

    addSession({ timeout, sessions, challenge, metadata })

    return challenge
  }

  /**
   * Verifies the noise payload from the initiator.
   * @param {Uint8Array} attestation
   * @throws {Error} If challenge wasn't found
   * @returns {{
   *  metadata: JSON,
   *  initiatorPK: Uint8Array,
   *  responderAttestation: Uint8Array,
   * }}
   */
  const verifyInitiator = (attestation) => {
    const handshake = createHandshake(false, keypair, { curve })
    handshake.initialise(PROLOGUE)

    const payload = handshake.recv(attestation)

    const { metadata: initiatorMetadata, rest: challenge } =
      msgs.decodePayload(payload)

    const id = hex(challenge)
    const session = sessions.get(id)

    if (!session) throw new Error(`Challenge ${id} not found`)

    sessions.delete(id)

    const responderAttestation = handshake.send(
      msgs.encodePayload(session.metadata, keypair.publicKey)
    )

    const metadata = msgs.safeParse(initiatorMetadata)

    return {
      metadata,
      initiatorPK: bint.concat([handshake.rs]),
      responderAttestation
    }
  }

  return {
    get config () {
      return _config
    },
    initiator: { respond },
    responder: {
      newChallenge,
      verifyInitiator,

      get sessions () {
        return sessions
      }
    }
  }
}

/** @typedef {import('./interfaces').KeyPair} KeyPair */
/** @typedef {import('./interfaces').Curve} Curve */
/** @typedef {import('./interfaces').Session} Session */
/** @typedef {import('./interfaces').JSON} JSON */
/** @typedef {import('./interfaces').Initiator} Initiator */
/** @typedef {import('./interfaces').Responder} Responder */
/** @typedef {import("noise-handshake")} Handshake */
