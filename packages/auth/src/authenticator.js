import {
  DEFAULT_CURVE,
  DEFAULT_CHALLENGE_LENGTH,
  AttestationSource,
  PROLOGUE
} from './constants.js'
import {
  generateChallenge,
  createHandshake,
  validateKeyForCurve
} from './crypto.js'
import { addSession, sessionID } from './sessions.js'
import * as msgs from './messages.js'
import bint from 'bint8array'

/**
 * @param {KeyPair} keypair - Authenticator's static keypair
 * @param {object} [config] - Authenticator's optional configurations
 * @param {Curve} [config.curve] - Eliptical curve used to create the hanshake
 * @param {Serializable} [config.metadata] - Metadata object
 * @param {number} [config.challengeLength]
 */
export const createAuth = (keypair, config = {}) => {
  // Defaults
  const curve = config.curve || DEFAULT_CURVE
  const challengeLength = config.challengeLength || DEFAULT_CHALLENGE_LENGTH

  /** Validate that the keypair is generated by the same curve used in handshake */
  validateKeyForCurve(curve, keypair.publicKey, keypair.secretKey)

  /**
   * Active sessions tracked by the responder
   * @type {Map<string, Session>}
   */
  const sessions = new Map()

  /**
   * Create a new session and return the combine of pubkey and challengeobject
   * @param {number} timeout - Timeout for the session in miliseconds
   * @param {Serializable} [metdata] - Custom metadata (overrides responder metadata)
   * @returns {Uint8Array} Encoded message with <version-code><PK><challenge>
   */
  const newChallenge = (timeout, metdata) => {
    const challenge = generateChallenge(challengeLength)

    const metadata = new TextEncoder().encode(
      JSON.stringify(metdata || config.metadata)
    )

    addSession({ timeout, sessions, challenge, metadata })

    return msgs.encodeChallenge(challenge, keypair.publicKey)
  }

  const intitiatorHandshake = createHandshake('IK', true, keypair, { curve })

  /**
   * Sign a challenge passed within an encoded message
   * Optionally: override metadata for this attestation
   * @param {Uint8Array} challengeMessage
   * @param {Serializable} [metdata] - Custom metadata (overrides responder metadata)
   * @returns {Uint8Array} Signed message
   */
  const signChallenge = (challengeMessage, metdata) => {
    const { remotePK, challenge } = msgs.decodeChallenge(challengeMessage)

    validateKeyForCurve(curve, remotePK)

    const metadata = new TextEncoder().encode(
      JSON.stringify(metdata || config.metadata)
    )

    intitiatorHandshake.initialise(PROLOGUE, remotePK)
    const signed = intitiatorHandshake.send(bint.concat([challenge, metadata]))
    return msgs.encodeAttestation(
      AttestationSource.Initiator,
      challenge.byteLength,
      signed
    )
  }

  /**
   * Verifies a signed message according to its source (initiator / responder)
   * @param {Uint8Array} attestation
   * @returns {{
   *  as: "Responder",
   *  metadata: Serializable,
   *  initiatorPK: Uint8Array,
   *  responderAttestation: Uint8Array,
   * } | {
   *  as: "Initiator",
   *  metadata: Serializable,
   *  responderPK: Uint8Array,
   * }} Signed message
   */
  const verify = (attestation) => {
    const { attestationSource, splitAt, signedMessage } =
      msgs.decodeAttestation(attestation)

    if (attestationSource === AttestationSource.Initiator) {
      const handshake = createHandshake('IK', false, keypair, { curve })
      handshake.initialise(PROLOGUE)

      const res = handshake.recv(signedMessage)
      const challenge = res.subarray(0, splitAt)
      const initiatorMetadata = res.subarray(splitAt)

      const id = sessionID(challenge)
      const session = sessions.get(id)

      if (!session) throw new Error(`Challenge ${id} not found`)

      sessions.delete(id)

      const msg = bint.concat([keypair.publicKey, session.metadata])

      const metadata = JSON.parse(new TextDecoder().decode(initiatorMetadata))

      return {
        as: 'Responder',
        metadata,
        initiatorPK: bint.concat([handshake.rs]),
        responderAttestation: msgs.encodeAttestation(
          AttestationSource.Responder,
          keypair.publicKey.byteLength,
          handshake.send(msg)
        )
      }
    } else if (attestationSource === AttestationSource.Responder) {
      const msg = intitiatorHandshake.recv(signedMessage)
      const responderPK = msg.slice(0, splitAt)

      const metadata = JSON.parse(new TextDecoder().decode(msg.slice(splitAt)))

      return {
        as: 'Initiator',
        responderPK,
        metadata
      }
    } else {
      throw new Error('Invalid Attestation source: ' + attestationSource)
    }
  }

  return {
    get config () {
      return {
        ...config,
        challengeLength,
        curve: curve
      }
    },
    get sessions () {
      return sessions
    },
    newChallenge,
    signChallenge,
    verify
  }
}

/** @typedef {import('./interfaces').KeyPair} KeyPair */
/** @typedef {import('./interfaces').Curve} Curve */
/** @typedef {import('./interfaces').Session} Session */
/** @typedef {import('./interfaces').Serializable} Serializable */
