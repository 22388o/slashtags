import {
  DEFAULT_CURVE,
  DEFAULT_CHALLENGE_LENGTH,
  AttestationSource,
  PROLOGUE,
} from './constants.js';
import {
  generateChallenge,
  createHandshake,
  validateKeyForCurve,
} from './crypto.js';
import { addSession } from './sessions.js';
import * as msgs from './messages.js';

/**
 * @param {KeyPair} keypair - Authenticator's static keypair
 * @param {object} [config] - Authenticator's optional configurations
 * @param {Curve} [config.curve] - Eliptical curve used to create the hanshake
 * @param {Serializable} [config.metadata] - Metadata object
 * @param {number} [config.challengeLength]
 */
export const createAuth = (keypair, config = {}) => {
  // Defaults
  const curve = config.curve || DEFAULT_CURVE;
  config.metadata = config.metadata;
  const challengeLength = config.challengeLength || DEFAULT_CHALLENGE_LENGTH;

  /** Validate that the keypair is generated by the same curve used in handshake */
  validateKeyForCurve(curve, keypair.publicKey, keypair.secretKey);

  /**
   * Active sessions tracked by the responder
   * @type {Map<string, Session>}
   */
  const sessions = new Map();

  /**
   * Create a new session and return the combine of pubkey and challengeobject
   * @param {number} timeout - Timeout for the session in miliseconds
   * @param {Serializable} [metdata] - Custom metadata (overrides responder metadata)
   * @returns {Uint8Array} Encoded message with <version-code><PK><challenge>
   */
  const newChallenge = (timeout, metdata) => {
    const challenge = generateChallenge(challengeLength);

    const metadata = new TextEncoder().encode(
      JSON.stringify(metdata || config.metadata),
    );

    addSession({ timeout, sessions, challenge, metadata });

    return msgs.encodeChallenge(challenge, keypair.publicKey);
  };

  /**
   * Sign a challenge passed within an encoded message
   * Optionally: override metadata for this attestation
   * @param {Uint8Array} challengeMessage
   * @param {Serializable} [metdata] - Custom metadata (overrides responder metadata)
   * @returns {Uint8Array} Signed message
   */
  const signChallenge = (challengeMessage, metdata) => {
    const { remotePK, challenge } = msgs.decodeChallenge(challengeMessage);

    validateKeyForCurve(curve, remotePK);

    const handshake = createHandshake('IK', true, keypair, { curve });

    handshake.initialise(PROLOGUE, remotePK);

    const metadata = new TextEncoder().encode(
      JSON.stringify(metdata || config.metadata),
    );

    const signed = handshake.send(Uint8Array.from([...challenge, ...metadata]));
    return msgs.encodeAttestation(
      AttestationSource.Initiator,
      challengeLength,
      signed,
    );
  };

  /**
   * Verifies a signed message according to its source (initiator / responder)
   * @param {Uint8Array} signedMessage
   * @returns {Uint8Array} Signed message
   */
  const verify = (signedMessage, metdata) => {};

  return {
    get config() {
      return {
        ...config,
        challengeLength,
        curve: curve,
      };
    },
    get sessions() {
      return sessions;
    },
    newChallenge,
    signChallenge,
  };
};

/** @typedef {import('./interfaces').KeyPair} KeyPair */
/** @typedef {import('./interfaces').Curve} Curve */
/** @typedef {import('./interfaces').Session} Session */
/** @typedef {import('./interfaces').Serializable} Serializable */
