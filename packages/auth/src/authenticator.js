import {
  DEFAULT_CURVE,
  DEFAULT_CHALLENGE_LENGTH,
  PROLOGUE
} from './constants.js'
import {
  generateChallenge,
  createHandshake,
  validateKeyForCurve
} from './crypto.js'
import { addSession, sessionID } from './sessions.js'
import * as msgs from './messages.js'
import bint from 'bint8array'

/**
 * @param {KeyPair} keypair - Authenticator's static keypair
 * @param {object} [config] - Authenticator's optional configurations
 * @param {Curve} [config.curve] - Eliptical curve used to create the hanshake
 * @param {JSON} [config.metadata] - Metadata object
 * @param {number} [config.challengeLength]
 * @returns {{
 *  config: {curve: Curve, challengeLength: number, metdata?: JSON},
 *  initiator: Initiator,
 *  responder: Responder
 * }}
 */
export const createAuth = (keypair, config = {}) => {
  // Defaults
  const curve = config.curve || DEFAULT_CURVE
  const challengeLength = config.challengeLength || DEFAULT_CHALLENGE_LENGTH
  const _config = { challengeLength, curve, metadata: config.metadata }

  /** Validate that the keypair is generated by the same curve used in handshake */
  validateKeyForCurve(curve, keypair.publicKey, keypair.secretKey)

  // Initiator

  /**
   * Verify a responder's attestation
   * @param {Handshake} handshake
   * @param {Uint8Array} remotePK
   * @param {Uint8Array} attestation
   * @throws {Error} If the attestation is invalid
   * @returns  {{
   *  metadata: JSON,
   *  responderPK: Uint8Array,
   * }}
   */
  const _verifyResponder = (handshake, remotePK, attestation) => {
    const { signedMessage, metadataOffset } =
      msgs.decodeAttestation(attestation)

    const msg = handshake.recv(signedMessage)
    const responderPK = msg.slice(0, metadataOffset)

    const metadata = JSON.parse(
      new TextDecoder().decode(msg.slice(metadataOffset))
    )

    return {
      metadata,
      responderPK
    }
  }

  /**
   * Sign a challenge passed within an encoded message
   * Optionally: override metadata for this attestation
   * @param {Uint8Array} challengeMessage
   * @param {JSON} [metdata] - Custom metadata (overrides responder metadata)
   */
  const signChallenge = (challengeMessage, metdata) => {
    const { remotePK, challenge } = msgs.decodeChallenge(challengeMessage)

    validateKeyForCurve(curve, remotePK)

    const metadata = new TextEncoder().encode(
      JSON.stringify(metdata || config.metadata)
    )

    const handshake = createHandshake(true, keypair, { curve })

    handshake.initialise(PROLOGUE, remotePK)
    const signed = handshake.send(bint.concat([challenge, metadata]))

    return {
      attestation: msgs.encodeAttestation(signed, challenge.byteLength),
      verifyResponder: (/** @type {Uint8Array} */ responderAttestation) =>
        _verifyResponder(handshake, remotePK, responderAttestation)
    }
  }

  // Responder

  /**
   * Active sessions tracked by the responder
   * @type {Map<string, Session>}
   */
  const sessions = new Map()

  /**
   * Create a new session and return an encoded tuple (challenge, responderPK)
   * @param {number} timeout - Timeout for the session in miliseconds
   * @param {JSON} [metdata] - Custom metadata (overrides responder metadata)
   * @returns {Uint8Array} Encoded message with <version-code><pkOffset><challenge><PK>
   */
  const newChallenge = (timeout, metdata) => {
    const challenge = generateChallenge(challengeLength)

    const metadata = new TextEncoder().encode(
      JSON.stringify(metdata || config.metadata)
    )

    addSession({ timeout, sessions, challenge, metadata })

    return msgs.encodeChallenge(challenge, keypair.publicKey)
  }

  /**
   * Verifies a signed challenge from the initiator.
   * @param {Uint8Array} attestation
   * @throws {Error} If challenge wasn't found
   * @returns {{
   *  metadata: JSON,
   *  initiatorPK: Uint8Array,
   *  responderAttestation: Uint8Array,
   * }}
   */
  const verifyInitiator = (attestation) => {
    const { signedMessage, metadataOffset } =
      msgs.decodeAttestation(attestation)

    const handshake = createHandshake(false, keypair, { curve })
    handshake.initialise(PROLOGUE)

    const res = handshake.recv(signedMessage)
    const challenge = res.subarray(0, metadataOffset)
    const initiatorMetadata = res.subarray(metadataOffset)

    const id = sessionID(challenge)
    const session = sessions.get(id)

    if (!session) throw new Error(`Challenge ${id} not found`)

    sessions.delete(id)

    const responderAttestation = handshake.send(
      bint.concat([keypair.publicKey, session.metadata])
    )

    const metadata = JSON.parse(new TextDecoder().decode(initiatorMetadata))

    return {
      metadata,
      initiatorPK: bint.concat([handshake.rs]),
      responderAttestation: msgs.encodeAttestation(
        responderAttestation,
        keypair.publicKey.byteLength
      )
    }
  }

  return {
    get config () {
      return _config
    },
    initiator: { signChallenge },
    responder: {
      newChallenge,
      verifyInitiator,

      get sessions () {
        return sessions
      }
    }
  }
}

/** @typedef {import('./interfaces').KeyPair} KeyPair */
/** @typedef {import('./interfaces').Curve} Curve */
/** @typedef {import('./interfaces').Session} Session */
/** @typedef {import('./interfaces').JSON} JSON */
/** @typedef {import('./interfaces').Initiator} Initiator */
/** @typedef {import('./interfaces').Responder} Responder */
/** @typedef {import("noise-handshake")} Handshake */
